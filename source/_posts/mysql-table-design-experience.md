---
title: MySQL 表设计经验
excerpt: 在进行MySQL数据库表设计时，应遵循一系列最佳实践以提升性能和可维护性。
tags:
  - MySQL
  - 表设计
categories:
  - MySQL
date: 2024-12-26 10:40:00
---

### 一、命名规范

- 表名、字段名必须使用小写字母或**数字 (不推荐)** 禁止使用数字开头，禁止使用拼音，并且一般不使用英文缩写
- 主键索引名为**pk_字段名**; 唯一索引名为**uk_字段名**; 普通索引名为 **idx_字段名**

### 二、合适的字段类型

- 尽可能选择存储空间小的字段类型，就比如数字类型，从 **tinyint (1byte)、smallint (2byte)、int (4byte)、bigint (8byte)**
- 小数类型如金额，必须选择 **decimal，禁止使用 float 和 double**
- 如果存储的字符串长度几乎相等，使用 char 定长字符串类型
- varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000
- 如果存储的字符串过长，建议字段类型修改为 **text**，同时**抽出单独的一张表，用主键与之对应**

### 三、主键设计合理

主键设计的话，最好不要与业务逻辑有所关联。有些业务上的字段，比如身份证，虽然是唯一的，一些开发者喜欢用它来做主键，但是不是很建议哈。主键最好是毫无意义的一串独立不重复的数字，比如
UUID，又或者 Auto_increment 自增的主键，或者是雪花算法生成的主键等等

### 四、合适的字段长度

比如一个用户名字段（它的长度 5~20 个字符），你觉得应该设置多长呢？可以考虑设置为 username varchar（32）。字段长度一般设置为 2
的幂（也就是 2 的 n 次方）。

- 为什么字段长度一般要设置为 2 的幂呢？

  这是因为数据库在存储数据时，会使用位运算来处理字段的长度，而位运算对于 2 的幂次方比较方便。如果字段长度不是 2
  的幂哈，则需要使用算术运算来处理，这样会降低数据库的性能。
  此外，设置字段长度为 2 的幂哈也有助于减少数据库的内存使用。数据库会根据字段长度来分配内存空间，如果字段长度不是 2
  的幂哈，则需要使用更大的内存块来存储，这样会造成内存的浪费。

- varchar(20) 和 varchar(255) 有什么区别？

  通常情况下使用 varchar(20) 和 varchar(255) 占用的空间都是一样的，但是使用**索引长度**有所不同。

- int(1) 和 nt(11) 有什么区别？
  在 MySQL 中，对于 int 类型的字段，设置其长度并不是指存储的数字位数或最大值的大小，而是指显示宽度。
  也就是说，**长度设置对实际存储的数据范围和占用空间并无影响**，它主要影响的是数据的**显示格式**。

  举个例子：

    1. 当长度设置为 1 的时候，表示当该字段值被查询并显示时，MySQL 会为这个整数值分配至少 1 个字符的宽度。如果实际值的位数小于
       1，MySQL 会在前面补足空格以达到指定的显示宽度；如果实际值的位数大于 1，则按照实际位数显示。例如，一个值为 123 的 INT
       字段，若设置长度为 1，实际显示时仍会完整显示为“123”，不会截断。
       2.当长度设置为 11 的时候，同理，表示当该字段值被查询并显示时，MySQL 会为其分配至少 11 个字符的宽度。同样，如果实际值的位数小于
       11，前面补足空格；若大于 11，则按实际位数显示。

- 为什么会看到有人喜欢设置 int(11) 呢？
  **最大可能位数**：INT 类型的最大可能位数是 10 位（不含正负号），即从 -2,147,483,648 到 2,147,483,647。设置长度为 11
  可以确保任何在这个范围内的整数值在显示时都不需要额外的填充空格。即使数值较小，如只有 1 位或 2
  位，也能保证有足够的宽度来容纳可能出现的最大位数，使得数据显示整齐且易于阅读。

其他建议：

1. 所有 int 类型使用默认长度即可
2. 为避免由于后期字段长度扩容，online ddl 走效率低的 copy 模式，建议：

- 对于 UTF8(MB3) 字符类型：
    - 字符个数小于 50 个，建议设置为 VARCHAR(50) 或更小的字符长度。
    - 字符个数接近 84（256/3=83.33）个，建议设置为 VARCHAR(84)  或更大的字符长度。
- 对于 UTF8MB4 字符类型：
    - 字符个数小于 50 个，建议设置为 VARCHAR(50)，或更小的字符长度。
    - 字符个数接近 64（256/4=64）个，建议设置为 VARCHAR(64) 或更大的字符长度。

### 五、优先逻辑删除

1. 为什么不推荐使用物理删除，因为恢复数据很困难
2. 物理删除会使自增主键不再连续
3. 核心业务表 的数据不建议做物理删除，只适合做状态变更。

### 六、通用字段

- id：主键，一个表必须得有主键，必须
- create_time：创建时间，必须
- update_time: 修改时间，必须，更新记录时，需要更新它
- version : 数据记录的版本号，用于乐观锁，非必须
- remark：数据记录备注，非必须
- update_by :修改人，非必须
- create_by：创建人，非必须

### 七、尽可能使用 not null 定义

1. NOT NULL 可以防止出现空指针的问题
2. NULL 值的存储也需要额外的空间，它也会导致比较运算更为复杂，使优化器难以优化 SQL
3. NULL 值有可能会导致索引失效

### 八、评估索引

评估你的表数据量。如果你的表数据量只有一百几十行，就没有必要加索引。否则设计表的时候，如果有查询条件的字段，一般就需要建立索引。但是索引也不能滥用：

- 索引也不要建得太多，一般单表索引个数不要超过 5 个。因为创建过多的索引，会降低写得速度。
- 区分度不高的字段，不能加索引，如性别等
- 索引创建完后，还是要注意避免索引失效的情况，如使用 mysql 的内置函数，会导致索引失效的
- 索引过多的话，可以通过联合索引的话方式来优化。然后的话，索引还有一些规则，如覆盖索引，最左匹配原则等等。

  假设你新建一张用户表，如下
  ```sql
  CREATE TABLE user_info_tab (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `age` int(11) DEFAULT NULL,
  `name` varchar(255) NOT NULL,
  `create_time` datetime NOT NULL,
  `update_time` datetime NOT NULL,
  PRIMARY KEY (`id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  ```
  对于这张表，很可能会根据 user_id 或者 name 查询用户信息，并且，user_id 是唯一的，因此是可以给 user_id 加上唯一索引，name
  加上普通索引索引
  ```sql
  CREATE TABLE user_info_tab (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `age` int(11) DEFAULT NULL,
  `name` varchar(255) NOT NULL,
  `create_time` datetime NOT NULL,
  `update_time` datetime NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`) USING BTREE,
  UNIQUE KEY uk_user_id (user_id)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
  ```

### 九、通过业务字段冗余来减少表关联

不需要严格遵守数据库三范式（3NF）

- 第一范式：对属性的原子性，要求属性具有原子性，不可再分解；
- 第二范式：对记录的唯一性，要求记录有唯一标识，即实体的唯一性，即不存在部分依赖；
- 第三方式：对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；

### 十、不使用外键

### 十一、没有特殊场景一般都选择 INNODB 存储引擎

除非读写比率小于 1%，才会考虑使用 MyISAM(也就是基本上都是读的场景)

### 十二、时间类型的选择

对于 MySQL 来说，主要有 date、datetime、time、timestamp 和 year

- date：表示的日期值 , 格式 yyyy-mm-dd, 范围 1000-01-01 到 9999-12-31，3 字节
- time：表示的时间值，格式 hh:mm:ss，范围 -838:59:59 到 838:59:59，3 字节
- datetime：表示的日期时间值，格式 yyyy-mm-dd hh:mm:ss，范围 1000-01-01 00:00:00 到 9999-12-31 23:59:59```,8 字节，跟时区无关
- timestamp：表示的时间戳值，格式为 yyyymmddhhmmss，范围 1970-01-01 00:00:01 到 2038-01-19 03:14:07，4 字节，跟时区有关
- year：年份值，格式为 yyyy。范围 1901 到 2155，1 字节

直接总结一下：推荐优先使用 datetime 类型来保存日期和时间，因为存储范围更大，且跟时区无关

### 十三、不建议在数据表中使用 Text 数据类型，而要单独开一张表放 Text 类型的数据

在 MySQL 的 InnoDB 引擎下，我们是通过 B+树去存储索引结构的，在 B+树中真正存储数据的都是叶子节点

而且我们一页只能存放 16KB 大小的数据，如果说你把 Text 数据和其他数据同时放在一张表，那么一条记录会比没放 Text
的时候要大很多，导致一个索引页存放的数据条数大大的减少

### 十四、SQL 优化经验

- 查询 SQL 不要使用 select * ,而是 select(具体字段)
- 避免在 where 子句中使用 or 来连接条件（可能会导致索引失效，因为 or 要两个条件都有索引）、
- 避免在索引列上使用 mysql 的内置函数
- 避免在 where 子句中对字段进行表达式操作，还有隐式转换
- 避免在 where 子句中使用 != 或 <> 操作符
- 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。
- 对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引
- 如果插入数据过多，考虑批量插入
- 在适当的时候，使用覆盖索引
- 使用 explain 分析你 SQL 的计划